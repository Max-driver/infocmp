# 项目文档

## 简介
| 文件名称			| 作用																																																								|
| ---						| ---																																																									|
| components		| 是一个用来存放组件的文件夹，从外部引用的组件，或者自己自定义的组件都是放在这个文件夹中															|
| pages					| 是一个用来存放所有页面的文件夹，也是我们经常操作的一个目录																													|
| static				| 是一个存放静态资源的文件夹，例如图片等																																							|
| unpackage			| 是打包目录，存放打包后的文件。有些新建项目目录中没有这个文件夹，在微信开发者工具等编译平台运行后，也会生成这个文件。|
| App.vue				| 是页面入口文件，所有页面都是在 App.vue 下进行切换的，可以调用应用的生命周期函数																			|
| main.js				| 是项目入口文件，主要用来初始化 vue 实例并使用需要的插件																															|
| manifest.json	| 是应用配置文件，用于指定应用的名称、图标、权限等																																		|
| pages.json		| 是全局配置文件，可以配置页面文件路径、窗口样式、原生的导航栏、底部 tab 栏等																					|
| uni.scss			| 是 uni-app 的样式包。在其他文件中可以快速引用样式包里面的样式																												|
|common					|是存放公共 js 和 css 的文件夹																																												|
|store					|是 vuex 状态管理文件夹，在 uni-app 项目内置了 vuex，使用时直接在 main.js 里面配置一下就可以了												|
 
其中 unpackage 目录存放的是打包后的文件，如果出现图片或者组件失效的情况，需要检查引用路径是否有错误。
## 内容

### home

#### 轮播图

##### 页面结构

- 先布局了顶部轮播图

```html
<!-- 轮播图 -->
<swiper :indicator-dots="true" :autoplay="true" :interval="3000" :duration="1000" :circular="true">
      <!-- 轮播图 iten 项 -->
      <swiper-item v-for="(item, index) in swiperList" :key="index">
        <navigator class="swiper-item" :url="'/subpkg/goods_detail/goods_detail?goods_id=' + item.goods_id">
          <!-- 动态获取图片src -->
          <image :src="item.image_src"></image>
        </navigator>
      </swiper-item>
</swiper>
```

    1. 使用 uni 内置轮播图组件 `<swiper><swiper-item></swiper-item></swiper>` 来完成布局
    2. 用超链接标签 `<navigation>` 循环渲染轮播图数据 swiperList

##### 业务逻辑

1. 在 methods 中定义 getSwiperList（）方法来访问后台获取轮播图数据

```js
async getSwiperList() {
      // 3.1 发起请求
      const { data: res } = await uni.$http.get('/api/public/v1/home/swiperdata');
      // 3.2 请求失败
      if (res.meta.status !== 200) {
        return uni.showToast();
      }
      // 3.3 请求成功，为 data 中的数据赋值
      this.swiperList = res.message;
    },
```

2. 然后在 data 中定义 swiperList[] 来保存后台返回的轮播图数据

3. 并且为 `<navigation>` 标签动态绑定 url 的值同时还要将商品参数 goods_id 一起传递指定的商品详情页 `goods_detail`

4. 并且我们要在进入页面时就看到轮播图所以要在页面的生命周期函数 onLoad（）中调用 getSwiperList（）方法

#### 导航栏

##### 页面结构

```html
<!-- 分类导航栏 -->
<view class="nav-list">
  <view class="nav-item" v-for="(item, index) in navList" :key="index" @click="navClickHandler(item)">
  <image :src="item.image_src" class="nav-img"></image>
  </view>
</view>
```

##### 业务逻辑

1. 获取导航栏图标数据的方法和轮播图一样，保存在 navList[] 中

2. 同样需要在进入页面时加载数据

3. 我们要在导航栏中绑定事件并传递参数来跳转到指定的页面

4. 在 methods 中定义绑定事件的处理函数 navClickHandler（）

```js
// 点击切换分类页面
navClickHandler(item) {
  if (item.name === '分类') {
    uni.switchTab({
      url: '/pages/cate/cate'
    });
  }
},
```

#### 楼层区

##### 页面结构

- 这里我们需要注意页面结构的左右的组成，并且注意为图片动态绑定样式

```html
<!-- 楼层区 -->
<view class="floor-list">
  <!-- item 项 -->
  <view class="floor-item" v-for="(item, index) in floorList" :key="index">
    <!-- 楼层标题 -->
    <image :src="item.floor_title.image_src" class="floor-title"></image>
    <!-- 楼层图片区 -->
    <view class="floor-img-box">
      <!-- 左 -->
      <navigator class="left-img-box" :url="item.product_list[0].url">
        <image :src="item.product_list[0].image_src" :style="{ width: item.product_list[0].image_width + 'rpx' }" mode="widthFix"></image>
      </navigator>
      <!-- 右 -->
      <view class="right-img-box">
        <navigator class="floor-img-item" v-for="(item2, index2) in item.product_list" :key="index2" v-if="index2 !== 0" :url="item2.url">
          <image :src="item2.image_src" mode="widthFix" :style="{ width: item2.image_width + 'rpx' }"></image>
        </navigator>
      </view>
    </view>
  </view>
</view>
```

##### 业务逻辑

1. 获取楼层的数据和之前的一样，保存在 floorList[] 中

2. 同样需要在进入页面时加载数据

#### 搜索框

##### 页面结构

- 这里我们通过 my-search 子组件来实现页面结构
```html
<!-- 搜索框 -->
<view class="search-box">
  <my-search @goSearch="gotoSearch"></my-search>
</view>
```

##### 业务逻辑

- 为子组件绑定自定义事件 `@goSearch="gotoSearch"` 来跳转到 search 页面

```js
// 跳转搜索页面
gotoSearch() {
  uni.navigateTo({
    url: '/subpkg/search/search'
  });
}
```

### my-search 组件

#### 页面结构

- 这里我们不使用真正的 input 文本框来实现搜索按钮，而是通过 view 来模拟一个 input 文本框，因为在这里我们仅仅只是用来展示文本框具体的逻辑要跳转到 search 页面实现

```html
<view class="my-search-container" :style="{ 'background-color': bgcolor }">
  <!-- 使用 view 组件模拟 input 输入框的样式 -->
  <view class="my-search-box" :style="{ 'border-radius': radius + 'px' }" @click="searchBoxHandler">
    <uni-icons type="search" size="17"></uni-icons>
    <text class="placeholder">搜索</text>
  </view>
</view>
```

#### 业务逻辑

1. 使用 view 来模拟文本框：通过 uni-icons 完成搜索框图标

2. 为模拟搜索框动态绑定样式 :style="{}"

3. 在 props 里面定义动态绑定的数据

```js
props: {
  // 背景颜色
  bgcolor: {
    type: String,
    default: '#C00000'
  },
  // 圆角尺寸
  radius: {
    type: Number,
    // 单位是 px
    default: 18
  }
},
```

4. 为该模拟搜索框绑定一个自定义事件 searchBoxHandler

5. 在 methods 中定义自定义事件的处理函数，这里不需要为自定义事件传递参数，直接触发父组件的自定义事件就行

```js
searchBoxHandler() {
      this.$emit('goSearch');
}
```

### search

#### 搜索框

##### 页面结构

- 我们使用第三方组件 uni-search-bar 来完成搜索框

```html
<!-- 使用 uni-ui 提供的搜索组件 -->
<view class="search-box">
  <uni-search-bar @input="getInput" :radius="100" cancelButton="none"></uni-search-bar>
</view>
```

##### 业务逻辑

1. 我们为搜索组件绑定自定义事件 getInput 来实现输入关键词时获取到服务器中的数据

2. 在 methods 中定义自定义事件的处理函数 getInput（），在该处理函数中我们需要作防抖处理，不能每输入一个字符就立马请求数据
    - 通过计时器 setTimeout() 来实现防抖功能，并且我们将请求数据的方法 getSearchList() 进行封装，在计时器里面调用该方法就行
    - 将 getSearchList() 返回的数据保存到 kw 中

```js
// 获取最新内容
getInput(e) {
  // 清除 timer 对应的延时器
  clearTimeout(this.timer);
  // 重新启动一个延时器，并把 timerId 赋值给 this.timer
  this.timer = setTimeout(() => {
    // 如果 500 毫秒内，没有触发新的输入事件，则为搜索关键词赋值
    this.kw = e.trim();
    // 根据 kw 来发起搜索请求
    this.getSearchList();
  }, 500);
},
```

3. 定义 getSearchList() 函数实现根据关键词来请求服务器数据，并且将发送请求的关键字保存为历史记录以便以后使用
    - 同样的我们将保存历史记录的方法进行封装为 saveSearchHistory() 我们直接在这里调用该方法就行
    - 并且将请求回来的数据保存到 searchResults[] 中

```js
// 根据搜索关键词，搜索商品建议列表
async getSearchList() {
  //先判断 kw 是否为空
  if (this.kw === '') {
    this.searchResults = [];
    return;
  }
  //不为空则发起请求
  const { data: res } = await uni.$http.get('/api/public/v1/goods/qsearch', { query: this.kw });
  if (res.meta.status !== 200) return uni.$showMsg();
  this.searchResults = res.message;
  //保存历史记录
  this.saveSearchHistory();
},
```

4. 定义 saveSearchHistory() 方法来保存历史记录，我们要将历史数据保存到本地
    - 将历史记录保存到 historyList[] 中
    - 并且通过调用 uni.setStorageSync() 方法来将发起请求的历史记录 kw 保存到本地
    
```js
// 保存搜索关键词为历史记录
saveSearchHistory() {
  // 解决重复的记录
  // 1. 将 Array 数组转化为 Set 对象
  const set = new Set(this.historyList);
  
  // 2. 调用 Set 对象的 delete 方法，移除对应的元素
  set.delete(this.kw);
  
  // 3. 调用 Set 对象的 add 方法，向 Set 中添加元素
  set.add(this.kw);
  
  // 4. 将 Set 对象转化为 Array 数组
  this.historyList = Array.from(set);
  
  // 调用 uni.setStorageSync(key, value) 将搜索历史记录持久化存储到本地
  uni.setStorageSync('kw', JSON.stringify(this.historyList));
},
```

5. 同样的我们需要在刚进入页面是就显示之前的历史记录，所以在生命周期函数 onLoad() 中调用 getStorageSync() 方法

```js
onLoad() {
    // 加载本地存储的历史记录
    this.historyList = JSON.parse(uni.getStorageSync('kw') || '[]');
  },
```

#### 搜索建议列表

##### 页面结构

- 在这里我们需要根据是否有对应的数据来 v-if 判断是否显示该列表，服务器没有对应的数据就不显示该列表
- 循环渲染后台返回的 searchResults[] 里面的商品列表
- 并且在建议列表中绑定点击事件 gotoDetail() 并传递对应商品的 goods_id 参数来前往对应的详情页

```vue
<!-- 搜索建议列表 -->
<view class="sugg-list" v-if="searchResults.length !== 0">
  <view class="sugg-item" v-for="(item, index) in searchResults" :key="index" @click="gotoDetail(item.goods_id)">
    <view class="goods-name">{{ item.goods_name }}</view>
    <uni-icons type="arrowright" size="16"></uni-icons>
  </view>
</view>
```

##### 业务逻辑

1. 在列表中通过绑定点击事件 gotoDetail() 跳转到详情页

2. 在 methods 中定义 gotoDetail() 方法来去往定义详情页

```js
gotoDetail(goods_id) {
  uni.navigateTo({
    // 指定详情页面的 URL 地址，并传递 goods_id 参数
    url: '/subpkg/goods_detail/goods_detail?goods_id=' + goods_id
  });
},
```

#### 搜索历史

##### 页面结构

- 跟前面的建议列表一样需要判断建议列表是否展示，如果展示了建议列表则不展示该组件使用 v-else 来达到展示其一的效果
- 并且绑定点击事件 cleanHistory() 来清除历史记录
- 使用第三方组件 uni-tag 来显示历史记录，并给该组件绑定点击事件 gotoGoodsList() 来跳转到对应的商品列表

```vue
<!-- 搜索历史 -->
<view class="history-box" v-else>
  <!-- 标题区 -->
  <view class="history-title">
    <text>搜索历史</text>
    <!-- 清除图标 -->
    <uni-icons type="trash" size="17" @click="cleanHistory"></uni-icons>
  </view>
  <!-- 列表区 -->
  <view class="history-list">
    <!-- uni-tag 组件 -->
    <uni-tag :text="item" v-for="(item, index) in historys" :key="index" @click="gotoGoodsList(item)">
    </uni-tag>
  </view>
</view>
```

##### 业务逻辑

1. 在 methods 中定义 cleanHistory() 方法来清空页面以及本地的历史记录，通过将本地记录设置为空达到清空记录的效果

```js
// 清空历史记录及本地历史记录
cleanHistory() {
  this.historyList = [];
  uni.setStorageSync('kw', '[]');
},
```

2. 再定义 gotoGoodsList() 方法来实现跳转到商品列表页面，记得在绑定该点击事件时要将搜索记录的关键词作为参数传入进来，不然无法展示指定的商品列表

```js
// 点击跳转到商品列表页面
gotoGoodsList(kw) {
  uni.navigateTo({
    url: '/subpkg/goods_list/goods_list?query=' + kw
  });
}
```

3. 目前通过 gotoGoodsList() 方法跳转到的页面是后台返回的这里我们需要去优化成一个单独的页面

##### 补充

1. 如果我们要实现将历史记录以头插法的形式来显示的话，就要将保存记录历史的数据数组 historyList[] 进行翻转，我们通过计算属性来实现

2. 我们在该页面的计算属性中将 historyList[] 进行翻转，并保存到 historyList 中供 uni-tag 组件渲染

    - reverse() 可以用来将数组里面的元素进行翻转
    - 但要清楚的是我们不能直接翻转 historyList[] 数组，因为这样会导致历史记录的顺序发生错乱，因此我们将该数组使用 ES6 进行解构为新数组后再进行翻转
    
```js
computed: {
  // 反转历史记录顺序
  historys() {
    // 由于数组是引用类型，所以不要直接基于原数组调用 reverse 方法，以免修改原数组中元素的顺序
    return [...this.historyList].reverse();
  }
},
```

### goods_list

#### 页面结构

- 根据后台获取数据来循环渲染 goods 组件，并且在每个渲染项中绑定点击事件 gotoDetail()

- 主要的页面结构都在 goods 组件中完成，而不是在当前 goods_list 页面中完成，因为不仅仅是当前页面需要商品信息列表，所以为了复用则采取组件的方式

```vue
<view class="goods-list">
  <view v-for="(item, index) in goodsList" :key="index" @click="gotoDetail(item)">
    <!-- 为 my-goods 组件动态绑定 goods 属性的值 -->
    <my-goods :goods="item"></my-goods>
  </view>
</view>
```

#### 业务逻辑

1. 从后台获取到商品列表数据后保存到 goodsList[] 中

    - 在这里获取后台列表数据时我们应该是按需来获取，而不是直接加载所有的商品信息，所以使用节流阀来控制请求次数，并且开启下拉刷新和上拉加载的方法

    - 需要注意的是我们这里发起请求的数据是一个对象，所以要在 data 中定义请求数据的参数对象 queryObj{} , 并且每次请求回来的数据使用 ES6 语法来拼接到 goodsList[] 中

    - 在每次请求完后记得要调用停止加载的回调函数不然会一直加载
```js
// 获取商品列表数据的方法
async getGoodsList(cb) {
  // ** 打开节流阀
  this.isloading = true;
  // 发起请求
  const { data: res } = await uni.$http.get('/api/public/v1/goods/search', this.queryObj);
  // ** 关闭节流阀
  this.isloading = false;

  // 只要数据请求完毕，就立即按需调用 cb 回调函数
  cb && cb();

  if (res.meta.status !== 200) return uni.$showMsg();
  // 为数据赋值：通过展开运算符的形式，进行新旧数据的拼接
  this.goodsList = [...this.goodsList, ...res.message.goods];
  this.total = res.message.total;
},
```

2. 定义与 methods 同级的 onReachBottom() 方法，实现上拉刷新和触底事件，要判断后台还有没有可以请求的数据，没有可以请求的数据则直接 return

    - 由于该方法是内置的所以我们在调用请求方法时不需要给回调函数，内部已经实现了上拉加载完后会停止加载

```js
// 下拉及触底事件
onReachBottom() {
  // 判断是否还有下一页数据: 当前的页码值 * 每页显示多少条数据 >= 总数条数
  if (this.queryObj.pagenum * this.queryObj.pagesize >= this.total) return uni.$showMsg('数据加载完毕');
  // 判断是否正在请求其它数据，如果是，则不发起额外的请求
  if (this.isloading) return;

  // 让页码值自增 +1
  this.queryObj.pagenum += 1;
  // 重新获取列表数据
  this.getGoodsList();
},
```

3. 定义与 methods 同级的 onPullDownRefresh() 方法来实现下拉刷新事件

    - 这里要调用发起请求的方法 getGoodsList() 并且给该方法一个回调函数来停止下拉刷新事件 

```js
// 下拉刷新事件
onPullDownRefresh() {
  //重置关键数据
  this.queryObj.pagenum = 1;
  this.total = 0;
  this.isloading = false;
  this.goodsList = [];

  // 重新发起请求, 并且通过回调函数来停止下拉刷新
  this.getGoodsList(() => uni.stopPullDownRefresh());
}
```

4. 定义 gotoDetail() 方法来实现点击循环项后跳转到对应商品的详细信息，记得接收传递的参数

```js
// 点击跳转到商品详情页面
gotoDetail(item) {
  uni.navigateTo({
    url: '/subpkg/goods_detail/goods_detail?goods_id=' + item.goods_id
  });
}
```

5. 将当前项的商品信息传递给 my-goods 组件 

```vue
<my-goods :goods="item"></my-goods>
```

6. 必须要在生命周期函数 onLoad() 中接收其它页面传递过来的参数并保存到 data 中，不然无法知道要请求的具体数据是什么，同时调用 getGoodsList() 方法一开始就请求一次数据

```js
onLoad(option) {
  // 将页面参数转存到 this.queryObj 对象中
  this.queryObj.query = option.query || '';
  this.queryObj.cid = option.cid || '';
  // 调用获取商品列表数据的方法
  this.getGoodsList();
},
```

### my-goods 组件

#### 左侧图片

##### 页面结构

- 由于该组件需要复用，所以我们要使用 v-if 来控制单选按钮 radio 是否显示，并为其绑定点击事件 radioClickHandler 来控制选中状态

```vue
<!-- 商品左侧图片区域 -->
<view class="goods-item-left">
  <!-- 使用 v-if 指令控制 radio 组件的显示与隐藏 -->
  <!-- 存储在购物车中的商品，包含 goods_state 属性，表示商品的勾选状态 -->
  <radio :checked="goods.goods_state" color="#C00000" v-if="showRadio" @click="radioClickHandler"></radio>
  <image :src="goods.goods_small_logo || defaultPic" class="goods-pic"></image>
</view>
```


##### 业务逻辑

1. 在 props 中接收其它页面传递的商品信息传送保存到 goods 对象中

2. 在 props 中定义 showRadio 对象来接收其它页面传递的传送，默认为 false 不显示该组件

3. 在 methods 中定义 radioClickHandler() 方法来处理 radio 组件的点击事件，向外传递对应的商品 id 和勾选状态的信息，外界通过使用对应的自定义事件 radio-change() 来接收该参数从而控制按钮的勾选状态

```js
// radio 组件的点击事件处理函数
radioClickHandler() {
  // 把商品的 Id 和 勾选状态 作为参数传递给 radio-change 事件处理函数
  this.$emit('radio-change', {
    // 商品的 Id
    goods_id: this.goods.goods_id,
    // 商品最新的勾选状态
    goods_state: !this.goods.goods_state
  });
},
```

4. 并且我们要给渲染的图片动态的绑定 src 属性，并且设置默认的图片 defaultPic ，该图片信息定义在 data 中

```js
:src="goods.goods_small_logo || defaultPic"
```

#### 右侧图片

##### 页面结构

- 我们使用第三方 uni-number-box 组件来完成商品数量的控制按钮，并且同样由于复用需要用 v-if 来控制是否显示该组件

- 绑定第三方组件的自定义事件 @change="numChangeHandler" 来修改商品数量

```vue
<!-- 商品右侧信息区域 -->
<view class="goods-item-right">
  <!-- 商品标题 -->
  <view class="goods-name">{{ goods.goods_name }}</view>
  <view class="goods-info-box">
    <!-- 商品价格 -->
    <view class="goods-price">￥{{ goods.goods_price | tofixed }}</view>
    <!-- 商品数量 -->
    <uni-number-box :min="1" :value="goods.goods_count" v-if="showNum" @change="numChangeHandler"></uni-number-box>
  </view>
</view>
```

##### 业务逻辑

1. 在 props 中定义 showNum 对象来保存其它页面传递的参数，从而判断是否显示 NumberBox 组件

2. 使用过滤器 filters 属性来将渲染的价格处理为带两位小数的数字

```js
// 过滤器
filters: {
  // 把数字处理为带两位小数点的数字
  tofixed(num) {
    return Number(num).toFixed(2);
  }
},
```

3. 在 methods 中定义 numChangeHandler() 方法来处理 uni-number-box 组件的 change 事件

```js
// NumberBox 组件的 change 事件处理函数
numChangeHandler(val) {
  this.$emit('num-change', {
    // 商品的 Id
    goods_id: this.goods.goods_id,
    // 商品的最新数量
    goods_count: +val
  });
}
```

### goods_detail

#### 注意

1. 对于这个页面我们需要在最外面的盒子设置 v-if 来判断是否有该商品再决定是否显示该页面，如果没有该商品则不显示该页面

2. 我们需要导入 store 中的 cart.js 的模块的共享数据和方法

```js
// 从 vuex 中按需导入辅助方法
import { mapState, mapMutations, mapGetters } from 'vuex';
```

3. 并且映射到计算属性 computed 和实例方法 methods 中供当前页面使用

```js
computed: {
  // 调用 mapState 方法，把 m_cart 模块中的 cart 数组映射到当前页面中，作为计算属性来使用
  // ...mapState('模块的名称', ['要映射的数据名称1', '要映射的数据名称2'])
  ...mapState('m_cart', ['']),
  // 把 m_cart 模块中名称为 total 的 getter 映射到当前页面中使用
  ...mapGetters('m_cart', ['total'])
},

methods: {
  // 把 m_cart 模块中的 addToCart 方法映射到当前页面使用
  ...mapMutations('m_cart', ['addToCart']),
}
```

#### 轮播图

##### 页面结构

- 使用内置的轮播图组件 swiper ，再循环渲染 swiper-item 

- 为循环渲染内部的 image 绑定点击事件 preview() 来实现轮播图对应索引的图片的预览

```vue
<!-- 轮播图区域 -->
<swiper :indicator-dots="true" :autoplay="true" :interval="3000" :duration="1000" :circular="true">
  <swiper-item v-for="(item, index) in goods_info.pics" :key="index">
    <!-- 把当前点击的图片的索引，传递到 preview() 处理函数中 -->
    <image :src="item.pics_big" @click="preview(index)"></image>
  </swiper-item>
</swiper>
```

##### 业务逻辑
 
1. 将请求的商品详细信息保存到 data 的 goods_info 对象中

1. 为 image 动态绑定 src 来渲染轮播图的图片

2. 再 methods 中定义点击事件 preview() 并接收对应的索引来实现预览对应图片的功能

    - 再该方法中调用 uni 内置的预览方法处理函数 previewImage()

    - 这里的 map() 会将将图片列表转化为合适的格式

```js
// 实现轮播图的预览效果
preview(index) {
  // 调用 uni.previewImage() 方法预览图片
  uni.previewImage({
    // 预览时，默认显示图片的索引
    current: index,
    // 所有图片 url 地址的数组
    urls: this.goods_info.pics.map(x => x.pics_big)
  });
},
```

#### 商品信息

##### 页面结构
 
- 收藏图标使用 uni 内置组件库 uni-icons 来实现

```vue
<!-- 商品信息区域 -->
<view class="goods-info-box">
  <!-- 1、 商品价格 -->
  <view class="price">￥{{ goods_info.goods_price }}</view>

  <!-- 2、 信息主体区域 -->
  <view class="goods-info-body">
    <!-- 商品名称 -->
    <view class="goods-name">{{ goods_info.goods_name }}</view>
    <!-- 收藏 -->
    <view class="favi">
      <uni-icons type="star" size="18" color="gray"></uni-icons>
      <text>收藏</text>
    </view>
  </view>

  <!-- 3、 运费 -->
  <view class="yf">快递：免运费</view>
</view>
```

##### 业务逻辑

1. 使用 {{}} 语法来将对应的数据动态渲染到页面就行

2. 还有收藏的点击事件待完善

#### 商品详情信息

##### 页面结构

- 由于该组件使用的是富文本标签，并且里面的内容后台也为我们处理好了，所以不需要而外设计，然而真正的开发中是需要自己完成结构处理而不是直接接收后台处理好的结构数据

```vue
<!-- 商品详情信息 -->
<rich-text :nodes="goods_info.goods_introduce"></rich-text>
```

##### 业务逻辑

- 为富文本标签 rich-text 动态绑定 nodes 属性就行了

#### 商品导航组件

##### 页面结构

- 使用第三方组件 uni-goods-nav 来实现导航组件功能

- 除了给该组件绑定一些属性外需要为其绑定点击事件来完成标题按钮的对应功能，左侧按钮绑定 @click="onClick" 事件，右侧按钮绑定 @buttonClick="buttonClick" 事件

```vue
<!-- 商品导航组件 -->
<view class="goods_nav">
  <!-- fill 控制右侧按钮的样式 -->
  <!-- options 左侧按钮的配置项 -->
  <!-- buttonGroup 右侧按钮的配置项 -->
  <!-- click 左侧按钮的点击事件处理函数 -->
  <!-- buttonClick 右侧按钮的点击事件处理函数 -->
  <uni-goods-nav :fill="true" :options="options" :buttonGroup="buttonGrop" @click="onClick" @buttonClick="buttonClick"></uni-goods-nav>
</view>
```

##### 业务逻辑

1. 再 methods 中定义 onClick(e) 方法作为 uni-goods-nav 组件左侧的点击处理函数，实现跳转到对应的页面

    - 需要注意的是这里我们不能使用组件的按钮对应的索引来判断用户点击的是哪一个按钮，因为索引会由于按钮的增删改变，应该直接判断按钮的内容

    - 按钮的内容定义在了 data 的 options 属性中，并且已经动态绑定到组件中了

```js
// uni-goods-nav 左侧按钮的点击事件处理函数
onClick(e) {
  if (e.content.text === '店铺') {
    console.log('店铺');
  }
  // 跳转到购物车页面
  else if (e.content.text === '购物车') {
    uni.switchTab({
      url: '/pages/cart/cart'
    });
  }
},
```

2. 再定义 buttonClick(e) 方法作为 uni-goods-nav 组件右侧按钮点击事件的处理函数，来实现对应功能

    - 同样的不能用索引作为判断条件，并且右侧的按钮的内容定义在了 data 的 buttonGrop 属性中

    - 由于多个组件需要用到加入购物车的商品的信息数据，所以这里我们使用 vue 提供的 vuex 来统一的管理多组件需要使用的数据

    - 我们要在点击了加入购物车按钮后调用 stroe 映射的 addToCart() 方法来将当前加入购物车的商品信息添加到共享数据当中
```js
// uni-goods-nav 右侧按钮的点击事件处理函数
buttonClick(e) {
  // 点击了 加入购物车 按钮
  if (e.content.text === '加入购物车') {
    // 组织一个商品的信息对象
    const goods = {
      // 商品的Id
      goods_id: this.goods_info.goods_id,
      // 商品的名称
      goods_name: this.goods_info.goods_name,
      // 商品的价格
      goods_price: this.goods_info.goods_price,
      // 商品的数量
      goods_count: 1,
      // 商品的图片
      goods_small_logo: this.goods_info.goods_small_logo,
      // 商品的勾选状态
      goods_state: true
    };
    // 通过 this 调用映射过来的 addToCart 方法，把商品信息对象存储到购物车中
    this.addToCart(goods);
  }
  // 跳转到购买订单页面
  else if (e.content.text === '立即购买') {
    // uni.switchTab({
    //   url: '/pages/my/my'
    // });
  }
}
```

3. 我们在计算属性 computed 中映射了 stroe 的 getters 中的 total 方法属性来供当前页面使用加入购物车的总数量

4. 通过监听器 watch 来监听购物车数量 total 的变化，当总数量发生变化后就调用处理函数 handler() 来动态设置购物车按钮的徽标，并且添加 immediate: true 属性来保证一开始就调用一次设置徽标的处理函数 handler()

5. 在 onLoad() 中调用请求商品详情数据的方法，以便一进入页面就可以看见数据

### stroe

#### 注意

1. 如果我们想要全局使用 vuex 的 store 不仅仅需要创建 store 实例对象，还需要在 main.js 文件中将 store 挂载到 vue 实例中

```js
const app = new Vue({
  ...App,
  // 将 store 挂载到 Vue 实例上
  store
})
```

2. 当我们需要使用 store 中的模块方法和数据时需要先映射到需要使用的页面后才能使用，一般采用 mapState, mapMutations, mapGetters 三个辅助函数来分别导入 store 模块的 state、mutations、getters 属性

    - 并且 state 和 getters 是映射为计算属性 computed，而 mutations 则映射为 methods 方法

```js
computed: {
  // 将 m_cart 模块中的 state 数据和 getters 属性映射到当前页面中使用
  ...mapState('m_cart', ['']),
  ...mapGetters('m_cart', [''])
},

methods: {
  // 将 m_cart 模块中的 mutations 中的方法映射到当前页面使用
  ...mapMutations('m_cart', ['']),
}
```

#### 创建 store.js

1. 记得创建 store 时要将 vuex 安装为 vue 的创建以此来全局访问 vuex

2. 我们选择只创建 Stroe 实力对象，而对于具体的数据管理我们采用导入模块的形式来实现，这样便于管理和维护，并且可以降低耦合性。

3. 我们导入了购物车模块 cart.js 和用户模块 user.js 的数据管理

4. 将导入的模块挂载到 stroe 实例对象的 modules 属性中

```js
// 导入 Vue 和 Vuex
import Vue from "vue"
import Vuex from "vuex"
// 导入购物车的 vuex 模块
import moduleCart from "./cart.js"
// 导入用户的 vuex 模块
import moduleUser from "./user.js"

// 将 Vuex 安装为 Vue 的插件
Vue.use(Vuex)

// 创建 Store 的实例对象
const store = new Vuex.Store({
  // TODO: 挂载 store 模块
  modules: {
    // 2. 挂载购物车的 vuex 模块，模块内成员的访问路径被调整为 m_cart，
    //    例如：购物车模块中 cart 数组的访问路径是 m_cart/cart
    m_cart: moduleCart,

    // 挂载用户的 vuex 模块，访问路径为 m_user
    m_user: moduleUser,
  },
})

// 向外共享 Store 的实例对象
export default store
```

#### cart.js 模块

1. 为当前模块开启命名空间来防止命名污染的问题

```js
// 为当前模块开启命名空间
namespaced: true,
```

##### state 数据

2. 在 state 中定义 cart 来存放加入购物车的商品信息，并且由于我们需要将数据存放在本地，所以从本地的数据获取数据存放到 cart 时使用 JSON 格式来获取本地数据

```js
// 模块的 state 数据
state: () => ({
  // 购物车的数组，用来存储购物车中每个商品的信息对象
  // 每个商品的信息对象，都包含如下 6 个属性：
  // { goods_id, goods_name, goods_price, goods_count, goods_small_logo, goods_state }
  cart: JSON.parse(uni.getStorageSync('cart') || '[]')
}),
```

##### mutations 方法

3. 在模块的 mutations 方法中定义添加商品到购物车的处理函数 addToCart()

    - 在 mutations 中的处理函数的第一个参数永远都是 state

    - 在 addToCart 方法中我们定义第二个参数来接收需要加入购物车的商品信息

    - 由于传入的商品信息是对象的格式，属于复杂类型，所以我们可以通过 find() 方法来判断购物车中 state.cart 是否存在要加入的数据并且返回 findResult ，返回的 findResult 是一个引用的格式，所以对 findResult 的修改就是直接对原有的数据 state.cart 进行修改

    - 在该方法中调用 saveToStorage() 方法来将接收的商品数据保存到本地中

    - 需要注意的是在 store 的模块中的方法如果想调用另一个方法需要用 commit() 来调用，不能直接使用函数名来调用

```js
addToCart(state, goods) {
  // 根据提交的商品的Id，查询购物车中是否存在这件商品
  // 如果不存在，则 findResult 为 undefined；否则，为查找到的商品信息对象
  const findResult = state.cart.find(x => x.goods_id === goods.goods_id)

  if (!findResult) {
    // 如果购物车中没有这件商品，则直接 push
    state.cart.push(goods)
  } else {
    // 如果购物车中有这件商品，则只更新数量即可
    findResult.goods_count++
  }

  // 通过 commit 方法，调用 m_cart 命名空间下的 saveToStorage 方法
  this.commit('m_cart/saveToStorage')
},
```

4. 定义 saveToStorage() 来将传入的数据保存到本地

    - 由于保存为本地数据需要是 JSON 格式的数据所以我们使用 JSON.stringify() 来将对象格式的数据进行转换

```js
// 将购物车中的数据持久化存储到本地
saveToStorage(state) {
  uni.setStorageSync('cart', JSON.stringify(state.cart))
},
```

5. 定义 updateGoodsState() 来更新购物车的勾选状态，同样的调用 saveToStorage() 方法来将勾选的状态保存到本地

```js
// 更新购物车中商品的勾选状态
updateGoodsState(state, goods) {
  // 根据 goods_id 查询购物车中对应商品的信息对象
  const findResult = state.cart.find(x => x.goods_id === goods.goods_id)

  // 有对应的商品信息对象
  if (findResult) {
    // 更新对应商品的勾选状态
    findResult.goods_state = goods.goods_state
    // 持久化存储到本地
    this.commit('m_cart/saveToStorage')
  }
},
```

6. 定义 updateGoodsCount() 来更新购物车中的商品数量，并持久化保存到本地

```js
// 更新购物车中商品的数量
updateGoodsCount(state, goods) {
  // 根据 goods_id 查询购物车中对应商品的信息对象
  const findResult = state.cart.find(x => x.goods_id === goods.goods_id)

  if (findResult) {
    // 更新对应商品的数量
    findResult.goods_count = goods.goods_count
    // 持久化存储到本地
    this.commit('m_cart/saveToStorage')
  }
},
```

7. 定义 removeGoodsById() 来根据商品 Id 删除购物车中的商品

    - 使用 filter() 方法来对数组的数据进行过滤

```js
// 根据 Id 从购物车中删除对应的商品信息
removeGoodsById(state, goods_id) {
  // 调用数组的 filter 方法将需要删除的商品进行过滤
  state.cart = state.cart.filter(x => x.goods_id !== goods_id)
  // 持久化存储到本地
  this.commit('m_cart/saveToStorage')
},
```

8. 定义 updateAllGoodsState() 来更新所有商品的勾选状态

```js
// 更新所有商品的勾选状态
updateAllGoodsState(state, newState) {
  // 循环更新购物车中每件商品的勾选状态
  state.cart.forEach(x => x.goods_state = newState)
  // 持久化存储到本地
  this.commit('m_cart/saveToStorage')
},
```

##### getters 数据包装器

9. 在 getters 属性中定义 total() 属性来统计购物车的数量

    - getters 属性里面定义的属性用来修改 state 中的数据，因为在 store 中不允许外界直接修改数据，只能通过 getters 中的属性来修改数据

```js
// 统计购物车的数量
total(state) {
  let c = 0
  // 循环统计商品的数量， 累加到变量 c 中
  state.cart.forEach(goods => c += goods.goods_count)
  return c
},
```

10. 定义 checkedCount() 属性来统计勾选的商品总数量

    - 需要注意 reduce() 的使用原因和使用方法

```js
// 勾选的商品的总数量
checkedCount(state) {
  // 先使用 filter 方法，从购物车中过滤器已勾选的商品
  // 再使用 reduce 方法，将已勾选的商品总数量进行累加
  // reduce() 的返回值就是已勾选的商品的总数量,将 0 作为 reduce() 方法的第二个参数，可以避免处理空数组时的异常情况。
  return state.cart.filter(x => x.goods_state).reduce((total, item) => total += item.goods_count, 0)
},
```

11. 定义 checkedGoodsAmount() 属性来统计已经勾选的商品总价

```js
// 已勾选的商品的总价
checkedGoodsAmount(state) {
  // 先使用 filter 方法，从购物车中过滤器已勾选的商品
  // 再使用 reduce 方法，将已勾选的商品数量 * 单价之后，进行累加
  // reduce() 的返回值就是已勾选的商品的总价
  // 最后调用 toFixed(2) 方法，保留两位小数
  return state.cart.filter(x => x.goods_state).reduce((total, item) => total += item.goods_count * item.goods_price,
    0).toFixed(2)
},
```

#### user.js 模块

1. 开启命名空间防止命名污染

```js
// 开启命名空间
namespaced: true,
```

##### state 数据

2. 定义 address token userinfo 对象属性来保存收货地址、登录成功之后的 token 和用户基本信息的数据

    - 同样的都需要从本地保存的数据中读取

```js
// 收货地址，读取本地的收货地址数据，初始化 address 对象
address: JSON.parse(uni.getStorageSync('address') || '{}'),

// 登录成功之后的 token 字符串
token: uni.getStorageSync('token') || '',

// 用户基本信息
userinfo: JSON.parse(uni.getStorageSync('userinfo' || '{}')),
```

3. 定义 redirectInfo 对象属性来保存重定向的 object 对象

    - 这个是不需要保存到本地的数据所以也就不用从本地读取，而且我们默认为空，需要用到该属性的时候在进行设置对应的数据

```js
// 重定向的 object 对象 { openType, from }
redirectInfo: null
```

##### mutations 方法

4. 定义 updateAddress() 来更新收货地址的信息，并且保存到本地中

```js
// 更新收货地址
updateAddress(state, address) {
  state.address = address

  // 2. 通过 this.commit() 方法，调用 m_user 模块下的 saveAddressToStorage 方法将 address 对象持久化存储到本地
  this.commit('m_user/saveAddressToStorage')
},
```

5. 定义 saveAddressToStorage() 来将 address 保存到本地

```js
// 1. 定义将 address 持久化存储到本地 mutations 方法
saveAddressToStorage(state) {
  uni.setStorageSync('address', JSON.stringify(state.address))
},
```

6. 定义 updateUserInfo() 来更新用户的基本信息，并保存到本地

```js
// 更新用户的基本信息
updateUserInfo(state, userinfo) {
  state.userinfo = userinfo
  // 通过 this.commit() 方法，调用 m_user 模块下的 saveUserInfoToStorage 方法，将 userinfo 对象持久化存储到本地
  this.commit('m_user/saveUserInfoToStorage')
},
```

7. 定义 saveUserInfoToStorage() 将 userinfo 保存到本地

```js
// 将 userinfo 持久化存储到本地
saveUserInfoToStorage(state) {
  uni.setStorageSync('userinfo', JSON.stringify(state.userinfo))
},
```

8. 定义 updateToken() 来更新用户的 token 字符串，并保存到本地

```js
// 更新 token 字符串
updateToken(state, token) {
  state.token = token

  // 通过 this.commit() 方法，调用 m_user 模块下的 saveTokenToStorage 方法，将 token 字符串持久化存储到本地
  this.commit('m_user/saveTokenToStorage')
},
```

9. 定义 saveTokenToStorage() 将用户的 token 保存到本地

```js
// 将 token 字符串持久化存储到本地
saveTokenToStorage(state) {
  uni.setStorageSync('token', state.token)
},
```

10. 定义 updateRedirectInfo() 来更新重定向的信息对象

```js
// 更新重定向的信息对象
updateRedirectInfo(state, info) {
  state.redirectInfo = info
},
```


##### getters 数据包装器

11. 定义 addstr 属性来动态保存详细的地址

```js
// 收货详细地址的计算属性 
addstr(state) {
  if (!state.address.provinceName) return '';

  // 拼接 省，市，区，详细地址 的字符串并返回给用户
  return state.address.provinceName + state.address.cityName + state.address.countyName + state.address.detailInfo;
},
```



### cate

#### 搜索组件

- 同 home 页面

#### 分类列表

##### 列表页面结构

- 用 uni 内置的 scroll-view 组件来完成滚动的一级列表

- 我们需要给该滚动列表动态的绑定一个固定高度 wh

- 循环渲染一级分类列表 cateList[] 的数据

- 我们需要给渲染的内容动态绑定 class 类来标识当前项，并且绑定点击事件 activeChanged() 来显示对应项的二级内容

```vue
<view class="scroll-view-container">
  <!-- 左侧的滚动视图区域 -->
  <scroll-view class="left-scroll-view" scroll-y :style="{ height: wh + 'px' }">
    <!-- DOTO 这里为什么用 block -->
    <block v-for="(item, index) in cateList" :key="index">
      <view :class="['left-scroll-view-item', index === active ? 'active' : '']" @click="activeChanged(index)">{{ item.cat_name }}</view>
    </block>
  </scroll-view>
  <!-- 右侧的滚动视图区域 -->
  <scroll-view class="right-scroll-view" scroll-y :style="{ height: wh + 'px' }" :scroll-top="scrollTop">
    <!-- 动态渲染二级分类的列表数据 -->
    <view class="cate-lv2" v-for="(item2, index2) in cateList2" :key="index2">
      <view class="cate-lv2-title">/{{ item2.cat_name }}/</view>
      <!-- 动态渲染三级分类的列表数据 -->
      <view class="cate-lv3-list">
        <view class="cate-lv3-item" v-for="(item3, index3) in item2.children" :key="index3" @click="gotoGoodsList(item3)">
          <!-- 图片 -->
          <image :src="item3.cat_icon"></image>
          <!-- 文本 -->
          <text>{{ item3.cat_name }}</text>
        </view>
      </view>
    </view>
  </scroll-view>
</view>
```

##### 一级列表业务逻辑

1. 获取服务器的一级分类列表的数据保存到 cateList[] 中

2. 再页面的周期函数 onLoad() 中动态获取屏幕的可用高度并保存到属性变量 wh 中，并且同时在 onLoad() 中调用 getCateList() 来一开始就加载页面数据

```js
onLoad() {
  // 获取当前系统的信息
  const sysInfo = uni.getSystemInfoSync();
  // 为 wh 窗口可用高度动态赋值，可用高度 = 屏幕高度 - navigationBar高度 - tabBar高度 - 自定义的search组件高度
  this.wh = sysInfo.windowHeight - 50;
  this.getCateList();
},
```

3. 定义 activeChanged() 方法来实现展示对应的二级列表，通过传递点击后对应的一级列表的索引来展示对应的二级列表的数据

```js
// 改变选择项,同时修改二级列表数据
activeChanged(index) {
  this.active = index;
  // 为二级分类列表重新赋值
  this.cateList2 = this.cateList[index].children;
  // 让 scrollTop 值在 0 或 1 进行变化，达到切换后仍然置顶的效果
  this.scrollTop = this.scrollTop === 0 ? 0.1 : 0;
},
```

##### 二级与三级列表业务逻辑

1. 在二级目录同样要获取后代数据保存到 cateList2[] 中，并且循环渲染该数据，要注意的是二级目录 cate-lv2 渲染的只是标题，而具体内容应该是放在里面的三级列表 cate-lv3-item 来渲染

2. 我们还要给三级列表绑定点击事件 gotoGoodsList() 并传递当前项为参数来跳转对应的商品列表页 goods_list

```js
gotoGoodsList(item3) {
  uni.navigateTo({
    url: '/subpkg/goods_list/goods_list?cid=' + item3.cat_id
  });
},
```
### cart

#### 地址栏

- 使用 my-address 组件

#### 商品列表标题

##### 页面结构

```vue
<!-- 购物车商品列表的标题区域 -->
<view class="cart-title">
  <!-- 左侧图标 -->
  <uni-icons type="shop" size="18"></uni-icons>
  <!-- 描述文本 -->
  <text class="cart-title-text">购物车</text>
</view>
```

##### 业务逻辑

- 无

#### 商品列表区域

##### 页面结构

- 使用第三方 uni-swipe-action 组件来实现向右滑动删除的效果

- 循环渲染 cart 中的商品

    - 并且在 uni-swipe-action-item 中定义点击事件 swipeActionClickHandler() 并传递当前商品信息来删除指定的商品

    - 使用 my-goods 组件来渲染商品详情，并传递 goods show-radio show-num 等自定义属性，绑定 @radio-change="radioChangeHandler" @num-change="numberChangeHandler 事件来改变商品数量和选择按钮

```vue
<!-- 商品列表区域 -->
<!-- uni-swipe-action 是最外层包裹性质的容器 -->
<uni-swipe-action>
  <block v-for="(goods, index) in cart" :key="index">
    <!-- uni-swipe-action-item 可以为其子节点提供滑动操作的效果。需要通过 options 属性来指定操作按钮的配置信息 -->
    <uni-swipe-action-item :right-options="options" @click="swipeActionClickHandler(goods)">
      <my-goods :goods="goods" :show-radio="true" :show-num="true" @radio-change="radioChangeHandler" @num-change="numberChangeHandler"></my-goods>
    </uni-swipe-action-item>
  </block>
</uni-swipe-action>
```

##### 业务逻辑

1. 在 computed 属性中映射 store 的 cart，以便当前页面可以使用 cart 的数据

```js
computed: {
  // 将 m_cart 模块中的 cart 数组映射到当前页面中使用
  ...mapState('m_cart', ['cart'])
},
```

2. 在 methods 中映射 store 的方法

```js
// 导入更新商品状态和数量的方法
...mapMutations('m_cart', ['updateGoodsState', 'updateGoodsCount', 'removeGoodsById']),
```

3. 定义 swipeActionClickHandler() 来处理滑动删除购物车商品，通过调用 store 的 removeGoodsById() 实现功能

```js
// 点击滑动删除购物项
swipeActionClickHandler(goods) {
  this.removeGoodsById(goods.goods_id);
}
```

4. 定义 radioChangeHandler() 来改变商品的勾选状态

```js
// 商品的勾选状态发生了变化
radioChangeHandler(e) {
  // e 的数据 -> {goods_id: 395, goods_state: false}
  // 商品的勾选状态发生了变化
  this.updateGoodsState(e);
},
```

5. 定义 numberChangeHandler() 来改变商品的数量

```js
// 商品的数量发生了变化
numberChangeHandler(e) {
  // 商品的数量发生了变化
  this.updateGoodsCount(e);
},
```

#### 结算区和空购物车

1. 使用 my-settle 组件来完成结算组件

```vue
<!-- 商品结算 -->
<my-settle></my-settle>
```

2. 商品数量为空时则显示默认图片

```vue
<view class="empty-cart" v-else>
  <image src="/static/cart_empty@2x.png" class="empty-img"></image>
  <text class="tip-text">空空如也~</text>
</view>
```

### my-address 组件

#### 页面结构

1. 未选择收货地址时的盒子，如果收货地址为空则显示该组件，并为按钮绑定点击事件 chooseAddress 来选择收货地址
```vue
<!-- 选择收货地址的盒子 -->
<!-- decodeURIComponent() -->
<view class="address-choose-box" v-if="JSON.stringify(address) === '{}'">
  <button type="primary" size="mini" class="btnChooseAddress" @click="chooseAddress">请选择收货地址+</button>
</view>
```

2. 收货信息的盒子，如果收货地址不为空则显示该组件，并且也绑定点击事件 chooseAddress 来更改地址

```vue
<!-- 渲染收货信息的盒子 -->
<view class="address-info-box" v-else @click="chooseAddress">
  <!-- 第一行 -->
  <view class="row1">
    <!-- 左边 -->
    <view class="row1-left">
      <view class="username">
        收货人：
        <text>{{ address.userName }}</text>
        <!-- <text>张三</text> -->
      </view>
    </view>
    <!-- 右边 -->
    <view class="row1-right">
      <view class="phone">
        电话：
        <text>{{ address.telNumber }}</text>
        <!-- <text>13879456780</text> -->
      </view>
      <uni-icons type="arrowright" size="16"></uni-icons>
    </view>
  </view>

  <!-- 第二行 -->
  <view class="row2">
    <view class="row2-left">收货地址：</view>
    <view class="row2-right">{{ addstr }}</view>
  </view>
</view>
```

3. 底部分割线

```vue
<!-- 底部的边框线 -->
<image src="/static/cart_border@2x.png" class="address-border"></image>
```

#### 业务逻辑

1. 记得导入 vuex 并且在 computed 和 methods 中映射所需的属性和方法

2. 定义 chooseAddress() 来处理选择收货地址的功能

    - 这里我们调用 wx 的 API 来选择收货地址，并且当用户选择了地址后要调用 updateAddress() 来将地址保存到本地中，如果选择地址时没有权限则调用 reAuth() 来让用户授权

```js
// 选择收货地址
async chooseAddress() {
  // 1. 调用小程序提供的 chooseAddress() 方法，即可使用选择收货地址的功能
  // const [err, succ] = await uni.chooseAddress().catch(err => err);

  // 新的微信 API 接口返回的是对象，不在是数组所以不能解构
  let res;
  try {
    const result = await uni.chooseAddress();
    res = [null, result];
  } catch (e) {
    res = [e, null];
  }
  const [err, result] = res;

  // 2. 用户成功的选择了收货地址
  if (err === null && result.errMsg === 'chooseAddress:ok') {
    // 为的收货地址对象赋值
    // this.address == result;
    // 更新 vuex 中的收货地址
    this.updateAddress(result);
  }

  // 3. 用户没有授权，安卓和苹果的提示不同
  if (err && (err.errMsg === 'chooseAddress:fail auth deny' || err.errMsg === 'chooseAddress:fail authorize no response')) {
    // 调用 this.reAuth() 方法，向用户重新发起授权申请
    this.reAuth();
  }
},
```

3. 定义 reAuth() 来重新设置收货地址权限

```js
// 调用此方法，重新发起收货地址的授权
async reAuth() {
  // 3.1 提示用户对地址进行授权
  // const [err2, confirmResult] = await uni.showModal({
  //   content: '检测到您没打开地址权限，是否去设置打开？',
  //   confirmText: '确定',
  //   cancelText: '取消'
  // });

  // API 返回对象不再是数组，所以无法解构
  const confirmResult = await uni.showModal({
    content: '检测到您没打开地址权限，是否去设置打开？',
    confirmText: '确定',
    cancelText: '取消'
  });

  // 3.2 如果弹框异常，则直接退出
  if (!confirmResult) return;

  // 3.3 如果用户点击了 “取消” 按钮，则提示用户 “您取消了地址授权！”
  if (confirmResult.cancel) return uni.$showMsg('您取消了授权！');

  // 3.4 如果用户点击了 “确认” 按钮，则调用 uni.openSetting() 方法进入授权页面，让用户重新进行授权
  if (confirmResult.confirm)
    return uni.openSetting({
      // 3.4.1 授权结束，需要对授权的结果做进一步判断
      success: settingResult => {
        // 3.4.2 地址授权的值等于 true，提示用户 “授权成功”
        if (settingResult.authSetting['scope.address']) return uni.$showMsg('授权成功！请选择地址');

        // 3.4.3 地址授权的值等于 false，提示用户 “您取消了地址授权”
        if (!settingResult.authSetting['scope.address']) return uni.$showMsg('您取消了地址授权');
      }
    });
}
```

### my-settle 组件

#### 页面结构

1. 全选区域，使用 radio 单选按钮来作为全选功能，并且为其绑定点击事件 changeAllState() 来改变所有商品的选中状态

```vue
<!-- 全选区域 -->
<label class="radio" @click="changeAllState">
  <radio color="#C00000" :checked="isFullCheck" />
  <text>全选</text>
</label>
```

2. 合计区域

```vue
<!-- 合计区域 -->
<view class="amount-box">
  合计：
  <text class="amount">￥{{ checkedGoodsAmount }}</text>
</view>
```

3. 结算区域，绑定点击事件 settlement() 来实现支付功能

```vue
<!-- 结算按钮 -->
<view class="btn-settle" @click="settlement">结算:({{ checkedCount }})</view>
```

#### 业务逻辑

1. 记得导入 vuex 和映射所需属性和方法

2. 定义 changeAllState() 来修改所有商品状态，这里我们传递调用 isFullCheck() 计算属性返回值的取反可以达到全选状态修改的效果

```js
// label 的点击事件处理函数，改变全选状态
// !this.isFullCheck 表示:当前全选按钮的状态取反之后，就是最新的勾选状态
changeAllState() {
  this.updateAllGoodsState(!this.isFullCheck);
},
```

3. 定义 isFullCheck() 计算属性来判断当前选中项是否等于全部商品项，并且动态渲染到全选按钮中

```js
isFullCheck() {
  return this.total === this.checkedCount;
}
```

4. 定义 settlement() 来进行结算处理，我们在结算前要判断是否满足结算所需条件，满足条件后再 调用 payOrder() 进行支付

```js
// 点击了结算按钮
settlement() {
  // 1. 先判断是否勾选了要结算的商品
  if (!this.checkedCount) return uni.$showMsg('请选择要结算的商品！');

  // 2. 再判断用户是否选择了收货地址
  if (!this.addstr) return uni.$showMsg('请选择收货地址！');

  // 3. 最后判断用户是否登录了,如果没有登录，则调用 delayNavigate() 进行倒计时的导航跳转
  // if (!this.token) return uni.$showMsg('请先登录');
  if (!this.token) return this.delayNavigate();

  // 4. 实现微信支付功能
  this.payOrder();
},
```

5. 定义 delayNavigate() 来实现倒计时跳转到 my 页面的效果，调用 showTips() 来显示倒计时的提示框

    - 我们采用定时器的方法实现倒计时跳转 my 页面，并且要节点每次调用该方法时都将计时时间初始化为3，在计时器结束时清除当前计时器

    - 在进行跳转页面时记得调用 updateRedirectInfo() 来记录当前页面，方便其它页面进行重定向会当前页面

```js
// 延迟导航到 my 页面
delayNavigate() {
  // 把 data 中的秒数重置成 3 秒
  this.seconds = 3;

  // 展示提示消息，此时 seconds 的值等于 3
  this.showTips(this.seconds);

  // 1. 将定时器的 Id 存储到 timer 中
  this.timer = setInterval(() => {
    this.seconds--;

    //------- 2. 判断秒数是否 <= 0 -----
    if (this.seconds <= 0) {
      // 2.1 清除定时器
      clearInterval(this.timer);

      // 2.2 跳转到 my 页面
      uni.switchTab({
        url: '/pages/my/my',
        // 页面跳转成功之后的回调函数
        success: () => {
          // 调用 vuex 的 updateRedirectInfo 方法，把跳转信息存储到 Store 中
          this.updateRedirectInfo({
            // 跳转的方式
            openType: 'switchTab',
            // 从哪个页面跳转过去的
            from: '/pages/cart/cart'
          });
        }
      });

      // 2.3 终止后续代码的运行（当秒数为 0 时，不再展示 toast 提示消息）
      return;
    }
    //---------------------------

    this.showTips(this.seconds);
  }, 1000);
},
```
6. 定义 showTips() 来实现倒计时提示框

```js
// 展示倒计时的提示消息
showTips(n) {
  // 调用 uni.showToast() 方法，展示提示消息
  uni.showToast({
    // 不展示任何图标
    icon: 'none',
    // 提示的消息
    title: '请登录后再结算!' + n + '秒后自动跳转到登录页',
    // 为页面添加透明遮罩，防止点击穿透
    mask: true,
    // 1.5 秒后自动消失
    duration: 1500
  });
},
```

7. 定义 payOrder() 来完成微信支付的功能

```js
// 微信支付
async payOrder() {
  // 1. 创建订单
  // 1.1 组织订单的信息对象
  const orderInfo = {
    // 开发期间，注释掉真实的订单价格，
    // 写死订单总价为 1 分钱
    // order_price: this.checkedGoodsAmount,
    order_price: 0.01,
    consignee_addr: this.addstr,
    goods: this.cart
      .filter(x => x.goods_state)
      .map(x => ({
        goods_id: x.goods_id,
        goods_number: x.goods_count,
        goods_price: x.goods_price
      }))
  };

  // 1.2 发起请求创建订单
  const { data: res } = await uni.$http.post('/api/public/v1/my/orders/create', orderInfo);

  if (res.meta.status !== 200) return uni.$showMsg('创建订单失败！');

  // 1.3 得到服务器响应的“订单编号”
  const orderNumber = res.message.order_number;

  // 2. 订单预支付
  // 2.1 发起请求获取订单的支付信息
  const { data: res2 } = await uni.$http.post('/api/public/v1/my/orders/req_unifiedorder', { order_number: orderNumber });
  // console.log(res2);

  // 2.2 预付订单生成失败
  if (res2.meta.status !== 200) return uni.$showMsg('预付订单生成失败！');

  // 2.3 得到订单支付相关的必要参数
  const payInfo = res2.message.pay;

  // 3. 发起微信支付
  // 3.1 调用 uni.requestPayment() 发起微信支付
  // const [err, succ] = await uni.requestPayment(payInfo);

  let res3;
  try {
    const succ = await uni.requestPayment(payInfo);
    res3 = [null, succ];
  } catch (e) {
    res3 = [e, null];
  }
  const [err, succ] = res3;

  // 3.2 未完成支付
  if (err) return uni.$showMsg('订单未支付！');

  // 3.3 完成了支付，进一步查询支付的结果
  const { data: res4 } = await uni.$http.post('/api/public/v1/my/orders/chkOrder', { order_number: orderNumber });

  // 3.4 检测到订单未支付
  if (res4.meta.status !== 200) return uni.$showMsg('订单未支付!');

  uni.showToast({
    title: '支付完成！',
    icon: 'success'
  });
}
```

### my

##### 页面结构

1. 登入页面，使用 my-login 组件来展示登入页面

2. 用户信息页面，使用 my-userinfo 组件来展示我的详细信息

```vue
<!-- 用户未登录时，显示登录组件 -->
<my-login v-if="!token"></my-login>

<!-- 用户登录后，显示用户信息组件 -->
<my-userinfo v-else></my-userinfo>
```

##### 业务逻辑

1. 导入 vuex 和映射所需的属性和方法

### my-login 组件

#### 页面结构

1. 提示登录的图标，使用内置的 uni-icons 组件

```vue
<!-- 提示登录的图标 -->
<uni-icons type="contact-filled" size="100"></uni-icons>
```

2. 登录按钮，绑定点击事件 getUserProfile() 来获取微信用户基本信息

```vue
<!-- 登录按钮 -->
<button type="primary" class="btn-login" @click="getUserProfile">一键登录</button>
```

3. 登录提示

```vue
<!-- 登录提示 -->
<view class="tips-text">登录后尽享更多权益</view>
```

#### 业务逻辑

1. 导入 vuex 和映射所需属性和方法

2. 定义 getUserProfile() 来回去用户基本信息，并且将用户信息保存到本地，调用 getToken() 来获取用户的 token

    - 由于后台的 token 无法获取所以这里使用测试 token

```js
// 获取微信用户的基本信息
//------这是微信新的接口-----------------------
getUserProfile() {
  uni.getUserProfile({
    desc: '你的授权信息',

    success: res => {
      // 3. 将用户的基本信息存储到 vuex 中
      this.updateUserInfo(res.userInfo);

      // 获取登录成功后的 Token 字符串
      // this.getToken(res);Max

      //------------------test--star-------------------------
      this.getToken('Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjIzLCJpYXQiOjE1NjQ3MzAwNzksImV4cCI6MTAwMTU2NDczMDA3OH0.YPt-XeLnjV-_1ITaXGY2FhxmCe4NvXuRnRB8OMCfnPo');
    },
    //------------------end-------------------------------

    fail: res => {
      return uni.$showMsg('您取消了登入授权');
    }
  });
},
```

3. 定义 getToken() 来获取永久的 token，如果成功获取 token 则调用 updateToken() 将 token 保存到本地，并且调用 navigateBack() 来判断是否需要重定向到其它页面

```js
// 调用登录接口换取永久的 token
async getToken(info) {
  // 调用微信登录接口, 获取 code 对应的值
  let res;
  try {
    const result = await uni.login();
    res = [null, result];
  } catch (e) {
    res = [e, null];
  }
  const [err, result] = res;
  
  // 判断是否 uni.login() 调用失败
  if (err || result.errMsg !== 'login:ok') return uni.$showError('登录失败!');

  //--------------Max--star-----------------------
  // 准备参数对象
  // const query = {
  //   code: result.code,
  //   encryptedData: info.encryptedData,
  //   iv: info.iv,
  //   rawData: info.rawData,
  //   signature: info.signature
  // };

  // 换取 token
  // const { data: loginResult } = await uni.$http.post('/api/public/v1/users/wxlogin', query);
  // if (loginResult.meta.status !== 200) return uni.$showMsg('登录失败!');

  // uni.$showMsg('登录成功');
  // 2. 更新 vuex 中的 token
  // this.updateToken(loginResult.message.token);
  //----------------Max--end---------------------

  //--------------test--star-------------------------
  if (!info) return uni.$showMsg('登录失败!');

  // 2. 更新 vuex 中的 token
  uni.$showMsg('登录成功');

  // 更新 vuex 中的 token
  this.updateToken(info);
  //----------------end-------------------------

  // 判断 vuex 中的 redirectInfo 是否为 null
  // 如果不为 null，则登录成功之后，需要重新导航到对应的页面
  this.navigateBack();
},
```

4. 定义 navigateBack() 来完成页面的重定向，并且完成重定向之后调用 updateRedirectInfo() 将重定向的值清空

```js
// 返回登录之前的页面
navigateBack() {
  // redirectInfo 不为 null，并且导航方式为 switchTab
  if (this.redirectInfo && this.redirectInfo.openType === 'switchTab') {
    // 调用小程序提供的 uni.switchTab() API 进行页面的导航
    uni.switchTab({
      // 要导航到的页面地址
      url: this.redirectInfo.from,

      // 导航成功之后，把 vuex 中的 redirectInfo 对象重置为 null
      complete: () => {
        this.updateRedirectInfo(null);
      }
    });
  }
}
```

### my-userinfo 组件

#### 页面结构

1. 头像区域

```vue
      <!-- 头像昵称区域 -->
      <view class="top-box">
        <image :src="userinfo.avatarUrl" class="avatar"></image>
        <view class="nickname">{{ userinfo.nickName }}</view>
      </view>
```

1. 第一个面板

```vue
<!-- 第一个面板 -->
<view class="panel">
  <!-- panel 的主体区域 -->
  <view class="panel-body">
    <!-- panel 的 item 项 -->
    <view class="panel-item">
      <text>8</text>
      <text>收藏的商品</text>
    </view>
    <view class="panel-item">
      <text>14</text>
      <text>收藏的店铺</text>
    </view>
    <view class="panel-item">
      <text>18</text>
      <text>关注的商品</text>
    </view>
    <view class="panel-item">
      <text>84</text>
      <text>足迹</text>
    </view>
  </view>
</view>
```

3. 第二个面板

```vue
<!-- 第二个面板 -->
<view class="panel">
  <!-- 面板的标题 -->
  <view class="panel-title">我的订单</view>
  <!-- 面板的主体 -->
  <view class="panel-body">
    <!-- 面板主体中的 item 项 -->
    <view class="panel-item">
      <image src="/static/my-icons/icon1.png" class="icon"></image>
      <text>待付款</text>
    </view>
    <view class="panel-item">
      <image src="/static/my-icons/icon2.png" class="icon"></image>
      <text>待收货</text>
    </view>
    <view class="panel-item">
      <image src="/static/my-icons/icon3.png" class="icon"></image>
      <text>退款/退货</text>
    </view>
    <view class="panel-item">
      <image src="/static/my-icons/icon4.png" class="icon"></image>
      <text>全部订单</text>
    </view>
  </view>
</view>
```

3. 第三个面板，为退出登录绑定点击事件 logout 来退出当前登录用户，并清空本地登录数据

```vue
<!-- 第三个面板 -->
<view class="panel">
  <view class="panel-list-item">
    <text>收货地址</text>
    <uni-icons type="arrowright" size="15"></uni-icons>
  </view>
  <view class="panel-list-item">
    <text>联系客服</text>
    <uni-icons type="arrowright" size="15"></uni-icons>
  </view>
  <view class="panel-list-item" @click="logout">
    <text>退出登录</text>
    <uni-icons type="arrowright" size="15"></uni-icons>
  </view>
</view>
```

#### 业务逻辑

1. 导入 vuex 和映射所需属性和方法

2. 定义 logout() 来退出当前用户，并且清空所有的用户本地数据

```js
// 退出登录
async logout() {
  // 询问用户是否退出登录
  const res = await uni
    .showModal({
      title: '提示',
      content: '确定退出登录吗？'
    })
    .catch(err => err);

  if (res && res.confirm) {
    // 用户确认了退出登录的操作
    // 需要清空 vuex 中的 userinfo、token 和 address
    this.updateUserInfo({});
    this.updateToken('');
    this.updateAddress({});
  }
}
```